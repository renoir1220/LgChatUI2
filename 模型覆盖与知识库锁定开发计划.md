# 模型覆盖与知识库锁定开发计划
本文档描述前后端改造计划，实现以下需求：
- 已开始的对话不能修改知识库。
- 当知识库配置 `canSelectModel` 为 true 时，在右侧显示一个模型（model）下拉；模型像 KB 一样从数据库配置、并带可见性控制。
- 选择模型后，发送给 Dify 时进行 model override，通过覆盖 chatflow 的模型实现模型切换。
- 模型配置使用 LgChatUI data service；模型表包含 dify provider、dify model_name、is_default，以及 available_users（权限控制同 KB）。

## 1. 范围和目标
- 范围：后端（数据层、接口层、Dify 接入）、前端（类型、状态、UI）、权限与校验、文档与轻量测试。
- 目标：在不破坏既有聊天流程的前提下，实现会话级模型选择与 Dify 流程覆盖，且与 KB 的权限模型一致。

## 2. 数据库设计
### 2.1 AI_MODEL（新）
使用 LgChatUI data service（与 KB 同库）。建议表结构：
- `ID` (PK, uniqueidentifier/varchar)
- `PROVIDER` (nvarchar) — dify provider 标识
- `MODEL_NAME` (nvarchar) — dify 模型名
- `IS_DEFAULT` (bit) — 是否默认模型
- `AVAILABLE_USERS` (nvarchar) — 可访问用户名，逗号分隔；为空表示所有用户可见
- 可选：`ENABLED`、`SORT_ORDER`、`CREATED_AT`、`UPDATED_AT`（与 KB 保持风格一致）

权限控制：
- 若 `AVAILABLE_USERS` 为空：对所有登录用户可见。
- 否则仅 `AVAILABLE_USERS` 中列出的用户可见（同 KB 实现）。

### 2.2 AI_KNOWLEDGE_BASES（变更）
- 新增 `CAN_SELECT_MODEL` (bit，默认 0)：是否允许在该知识库下选择模型。

## 3. 后端改造
### 3.1 Repository（新）
- `ModelRepository`
  - `findEnabledByUser(username)`：返回当前用户可见的模型列表，按 `AVAILABLE_USERS` 过滤、按 `SORT_ORDER/PROVIDER/MODEL_NAME` 排序。
  - `findDefaultByUser(username)`：返回可见集合中的首个 `IS_DEFAULT=1` 模型。
  - `findById(id)`：按 ID 查找模型记录。

### 3.2 Controller / Service（新与改）
- 新增：`GET /api/models`（需登录）
  - 返回字段：`id`, `provider`, `modelName`, `isDefault`（不含敏感信息）
- 会话更新：`PUT /api/conversations/:id`
  - 规则：若请求包含 `knowledgeBaseId` 且会话已有消息（message_count > 0），返回 400，提示“已开始的对话不能修改知识库”。
  - 新增可选字段 `modelId`（会话级持久化，见 5.2）。
- 聊天接口：`POST /api/chat`
  - 接收 `modelId?: string`（扩展现有 `ChatRequest`）。
  - 将 `modelId` 传入 Dify 调用路径。

### 3.3 DifyService model override
- 时机：当 KB 的 `canSelectModel = true` 时启用模型覆盖；否则沿用 KB 默认配置。
- 选择：若请求未带 `modelId`，则读取当前用户可见的 `is_default` 模型；若仍无，继续使用 KB 默认（不覆盖）。
- 覆盖方式：在请求体 `inputs` 注入覆盖键（建议）：
  - `inputs.model_provider = <PROVIDER>`
  - `inputs.model_name = <MODEL_NAME>`
- 由 Chatflow 在模型节点读取上述 inputs 并覆盖实际使用模型（变量名如需调整，请在评审时确认）。

## 4. 前端改造
### 4.1 类型与 API
- 新增类型 `AIModel`：`{ id, provider, modelName, isDefault }`
- 新增 API：`GET /api/models`
- 扩展 `ChatRequest`：新增 `modelId?: string`

### 4.2 状态与上下文
- 在 `ChatContext` 增加 `models` 与 `selectedModelId` 状态；初始化并行加载 KB 与 Model 列表。
- 若用户未手动选择模型，则默认选中 `isDefault` 模型。

### 4.3 UI 与交互
- 知识库下拉：当会话已开始（已存在消息）时禁用 KB 下拉（灰显 + 提示）。
- 模型下拉：当当前 KB 配置 `canSelectModel = true` 时，右侧显示模型下拉；切换时更新 `selectedModelId`。
- 持久化（推荐）：当存在当前会话 ID 时，切换模型后调用 `PUT /api/conversations/:id` 保存 `modelId`，实现会话记忆。
- 发送消息：在 `ChatRequest` 中携带 `modelId`，后端依据 3.3 执行覆盖。

## 5. 会话约束与持久化
### 5.1 KB 锁定
- 前端：在 UI 禁用；
- 后端：在 `PUT /api/conversations/:id` 中校验消息数量，强制禁止变更 KB。

### 5.2 Model 会话级持久化（可选但推荐）
- `AI_CONVERSATIONS` 新增列 `MODEL_ID`；
- 在 `PUT /api/conversations/:id` 中保存 `modelId`；
- 下次进入会话时自动选中该模型。

## 6. 风险与回退
- 覆盖键名与 Chatflow 变量需一致：需要与你确认；若不一致将导致覆盖无效。
- 若用户无可用模型（权限过滤后为空）：UI 隐藏下拉，后端不覆盖，使用 KB 默认。
- 回退策略：模型覆盖仅在 `canSelectModel = true` 的 KB 中生效，其他 KB 不受影响。

## 7. 验收清单
- [ ] 已开始会话尝试修改 KB：前端禁用、后端返回 400。
- [ ] `canSelectModel = true` 的 KB 显示模型下拉，权限过滤生效。
- [ ] 选择不同模型，Dify 实际生效（可通过日志/控制台验证 provider/model_name）。
- [ ] 未选择模型时，默认使用用户可见的 is_default 模型。
- [ ] 非“对话”KB 不出现模型下拉，行为不变。

## 8. 实施步骤与顺序
1) 数据层：`AI_MODEL` 表与 `ModelRepository`（已对齐 KB 权限过滤）
2) 后端接口：`GET /api/models`，会话 KB 锁定校验
3) Dify 覆盖：`ChatRequest` 扩展 `modelId`，DifyService 注入 `inputs.model_provider/model_name`
4) 前端：类型与 API 扩展；上下文加载 models；UI（KB 锁定 + 模型下拉）
5) 会话持久化：`MODEL_ID` 字段与 PUT 保存
6) 文档与轻量测试：补充 docs/MODEL_OVERRIDE.md，用例验证


## 参考代码
-如何调用dify chatflow时传入provider和model？
{
  "inputs": {
    "question": "帮我总结这段话"
  },
  "response_mode": "streaming",
  "user": "user-123",
  "model_config": {
    "provider": "openai",
    "model": "gpt-4o-mini",
    "temperature": 0.2,
    "max_tokens": 1024
  }
}

---
注：若 Chatflow 需要其他覆盖键名，请确认后我会调整注入键名与文档说明。
